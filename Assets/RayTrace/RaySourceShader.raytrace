#include "UnityShaderVariables.cginc"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "RayCommon.raytrace"

#pragma max_recursion_depth 1

// Input
RaytracingAccelerationStructure g_SceneAccelStruct;
Texture2D<float4> g_Albedo;
Texture2D<float4> g_Normal;
Texture2D<float4> g_Depths;
Texture2D<float4> g_Motion;
float g_Zoom; //Mathf.Tan(Mathf.Deg2Rad * Camera.main.fieldOfView * 0.5f)

// Output
RWTexture2D<float4> g_Output : register(u0);

float3 SampleEnvironmentMapColour(float3 direction)
{
    float3 toLightDir = normalize(_WorldSpaceLightPos0.xyz);
    return dot(direction, toLightDir) > 0.999 ? 1.0 : 0.0;
}

float3 SampleEnvironmentMapRadience(float3 direction)
{
    return SampleEnvironmentMapColour(direction) * 10.0;
}

[shader("miss")]
void MainMissShader(inout RayPayload payload)
{
    float3 rayDirW = normalize(WorldRayDirection());
    float3 rayOriginW = WorldRayOrigin();

    payload.worldPosition = rayDirW * 1000.0f;
    payload.albedo = SampleEnvironmentMapColour(rayDirW);
    payload.radiance = SampleEnvironmentMapRadience(rayDirW);
    payload.worldNormal = 0.0;
}

[shader("raygeneration")]
void MainRayGenShader()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;
    uint xorBitValue = (launchIndex.x ^ launchIndex.y) & 0x000000FF;
    float normalizedXorValue = (float) xorBitValue / 255.0f;

    float2 frameCoord = float2(launchIndex.x, launchDim.y - launchIndex.y - 1) + float2(0.5, 0.5);

    float2 uvCoords = frameCoord / float2(launchDim.x - 1, launchDim.y - 1);
    float3 worldPosition = ComputeWorldSpacePosition(uvCoords, g_Depths[frameCoord].r, Inverse(UNITY_MATRIX_VP));
    float3 worldNormal = normalize(g_Normal[frameCoord].xyz);

    float2 ndcCoords = uvCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    float aspectRatio = (float)launchDim.x / (float)launchDim.y;

    float3 viewDirection = normalize(float3(ndcCoords.x * aspectRatio, ndcCoords.y, 1));

    // Rotate the ray from view space to world space.
    float3 toCameraDir = -normalize(mul((float3x3)unity_CameraToWorld, viewDirection));
    float3 toLightDir = normalize(_WorldSpaceLightPos0.xyz);

    // Emperically decided for the scene
    float3 adjustedWorldPosition = worldPosition + worldNormal * 1e-2;

    float3 firstBounceRadiance = 0.0;
    float3 firstBounceAlbedo = g_Albedo[frameCoord];

    // Todo: Replace with proper environment map
    if (length(firstBounceAlbedo.xyz) < 1e-6) {
        firstBounceRadiance = SampleEnvironmentMapRadience(-toCameraDir);
        firstBounceAlbedo = SampleEnvironmentMapColour(-toCameraDir);
    }

    float3 radiance = firstBounceRadiance;
    float3 colour = 1.0f * firstBounceAlbedo; /* First founce colour */

    RayDesc ray;
    RayPayload reflectRayPayload;
    RayPayload lightRayPayload;
    uint missShaderIndex = 0;

    reflectRayPayload.worldPosition = adjustedWorldPosition;
    reflectRayPayload.worldNormal = worldNormal;
    float3 intersectIncidentVector = normalize(reflect(-toCameraDir, reflectRayPayload.worldNormal));

    // If we hit the skybox, stop sampling
    for (uint i = 0; i < 5 && length(reflectRayPayload.worldNormal) > 1e-6; i++)
    {
        float3 intersectWorldPosition = reflectRayPayload.worldPosition;
        float3 intersectWorldNormal = reflectRayPayload.worldNormal;

        float weightShadow = max(dot(toLightDir, intersectWorldNormal), 0.0);
        float weightReflect = max(dot(intersectIncidentVector, intersectWorldNormal), 0.0);
        float weightSum = weightShadow + weightReflect;

        // Always set the input data for the light ray and the reflection ray the same
        lightRayPayload = reflectRayPayload;

        ray.Origin    = intersectWorldPosition + intersectWorldNormal * 1e-4;
        ray.Direction = toLightDir;
        ray.TMin      = 0.0f;
        ray.TMax      = 1000.0f;

        // Shadow ray
        TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, lightRayPayload);

        radiance += colour * lightRayPayload.radiance * weightShadow / 10.0;

        ray.Origin    = intersectWorldPosition + intersectIncidentVector * 1e-4;
        ray.Direction = intersectIncidentVector;
        ray.TMin      = 0.0f;
        ray.TMax      = 1000.0f;

        // Reflection ray
        TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, reflectRayPayload);

        float3 incomingLightReflect = reflectRayPayload.albedo * reflectRayPayload.radiance * weightReflect;
        float3 incomingLightSkymap = lightRayPayload.albedo * lightRayPayload.radiance * weightShadow / 10.0;

        radiance += colour * lerp(incomingLightReflect, incomingLightSkymap, 0.5);

        colour *= reflectRayPayload.albedo;

        if (length(colour) < 0.01)
            break;

        // v_out = reflect(v_in, v_norm);
        intersectIncidentVector = reflect(intersectIncidentVector, reflectRayPayload.worldNormal);
    }

    g_Output[frameCoord] = float4(radiance, 1.0);
}